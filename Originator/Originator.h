// Copyright (C) 2018-2019 by denis bider. All rights reserved.

#pragma once

#include <stddef.h>
#include <stdint.h>


#ifdef COMPILING_ORIGINATOR
	#define ORIGINATOR_FUNC extern "C" __declspec(dllexport)
#else
	#define ORIGINATOR_FUNC extern "C" __declspec(dllimport)

	#ifdef _WIN64
		#pragma comment(lib, "Originator64.lib")
	#else
		#pragma comment(lib, "Originator32.lib")
	#endif
#endif

#ifdef _WIN64
	#pragma pack (push, 16)
#else
	#pragma pack (push, 8)
#endif

#pragma warning (push)
#pragma warning (disable: 4820)



struct OgnSeq
{
	char const*			p {};
	size_t				n {};
};

inline OgnSeq OgnSeq_Make(char const* p, size_t n)
{
	OgnSeq x;
	x.p = p;
	x.n = n;
	return x;
}



struct OgnResult
{
	bool				m_success;
	void*				m_storage;					// Null if m_success is true, otherwise MAY be set. If set, MUST be freed by the user with CoTaskMemFree or memory is leaked
	OgnSeq				m_errDesc;					// Empty if m_success is true. If set, MAY use m_storage if m_storage is set, or may point to memory which must not be freed
};



struct OgnEnumValInfo
{
	uint32_t			m_value {};
	char const*			m_name  {};
	char const*			m_desc  {};
};



struct OgnEnumValues
{
	void*					m_storage	{};			// If non-null, MUST be freed by the user with CoTaskMemFree; otherwise memory is leaked
	size_t					m_nrValues	{};
	OgnEnumValInfo const*	m_values	{};
};



struct OgnServiceState { enum E : uint32_t {
	NotStarted			=   0,
	Starting			= 100,
	Started				= 200,
	Stop_Waiting		= 300,
	Stop_Deinitializing	= 400,
	Stopped				= 500,
}; };



struct OgnAutoSbmtd { enum E : uint32_t {
	Invalid				=   0, 
	No					= 100,
	AutoGenerated		= 200,
	AutoReplied			= 300,
}; };



struct OgnRemoveResult { enum E : uint32_t {
	None				=   0,
	Found_Removed		= 100,
	Found_CannotRemove	= 200,
	NotFound			= 300,
}; };



struct OgnIpVerPref { enum E : uint32_t {
	None				= 0,
	Ip4					= 100,
	Ip6					= 200,
}; };

ORIGINATOR_FUNC char const* __cdecl OgnIpVerPref_Name      (uint32_t v);
ORIGINATOR_FUNC char const* __cdecl OgnIpVerPref_Desc      (uint32_t v);
ORIGINATOR_FUNC bool        __cdecl OgnIpVerPref_NameToVal (OgnSeq n, OgnIpVerPref::E& v);
ORIGINATOR_FUNC OgnResult   __cdecl OgnIpVerPref_Values    (OgnEnumValues& x);



struct OgnTlsAssurance { enum E : uint32_t {
	Unknown				= 0,
	NoTls				= 100,		// Message transferred in plaintext if counterparty does not offer/start TLS, or TLS fails
	Tls_NoHostAuth		= 200,		// Require TLS. No counterparty authentication
	Tls_AnyServer		= 300,		// Require TLS. Counterparty authenticates, but does not have to be a host in recipient domains
	Tls_DomainMatch		= 400,		// Require TLS. Counterparty MX authenticates itself as a host in recipient domains
	Tls_ExactMatch		= 500,		// Require TLS. Counterparty MX authenticates itself as the exact MX name we expect
}; };

ORIGINATOR_FUNC char const* __cdecl OgnTlsAssurance_Name      (uint32_t v);
ORIGINATOR_FUNC char const* __cdecl OgnTlsAssurance_Desc      (uint32_t v);
ORIGINATOR_FUNC bool        __cdecl OgnTlsAssurance_NameToVal (OgnSeq, OgnTlsAssurance::E& v);
ORIGINATOR_FUNC OgnResult   __cdecl OgnTlsAssurance_Values    (OgnEnumValues& x);



struct OgnAuthType { enum E : uint32_t {
	None				= 0,
	UseSuitable			= 100,
	AuthPlain			= 200,
	AuthCramMd5			= 300,
}; };

ORIGINATOR_FUNC char const* __cdecl OgnAuthType_Name      (uint32_t v);
ORIGINATOR_FUNC char const* __cdecl OgnAuthType_Desc      (uint32_t v);
ORIGINATOR_FUNC bool        __cdecl OgnAuthType_NameToVal (OgnSeq, OgnAuthType::E& v);
ORIGINATOR_FUNC OgnResult   __cdecl OgnAuthType_Values    (OgnEnumValues& x);



struct OgnMsgStatus { enum E : uint32_t {
	NonFinal_Idle			= 0,	// The message is enqueued, awaiting the next send attempt
	NonFinal_Sending		= 1,	// There is a currently ongoing attempt to send the message
	Final_Sent				= 2,	// During the last attempt, delivery succeeded for at least one mailbox. There were no pending temporary failures for other
									// mailboxes. There may have been permanent failures for some mailboxes, either in the last or a previous sending attempt.
	Final_Failed			= 3,	// During the last attempt, delivery to all remaining mailboxes failed permanently.
	Final_Aborted			= 4,	// Currently not used in Originator. The post-delivery event handler that could abort the message is not exposed and never aborts.
	Final_GivenUp			= 5,	// During the last attempt, there were one or more temporary failures, but the retry schedule for the message was exhausted.
}; };

ORIGINATOR_FUNC char const* __cdecl OgnMsgStatus_Name      (uint32_t v);
ORIGINATOR_FUNC char const* __cdecl OgnMsgStatus_Desc      (uint32_t v);
ORIGINATOR_FUNC bool        __cdecl OgnMsgStatus_NameToVal (OgnSeq, OgnMsgStatus::E& v);
ORIGINATOR_FUNC OgnResult   __cdecl OgnMsgStatus_Values    (OgnEnumValues& x);



struct OgnDeliveryState { enum E : uint32_t {
	None				= 0,
	TempFailure			= 1,
	PermFailure			= 2,
	Success				= 3,
}; };

ORIGINATOR_FUNC char const* __cdecl OgnDeliveryState_Name      (uint32_t v);
ORIGINATOR_FUNC char const* __cdecl OgnDeliveryState_Desc      (uint32_t v);
ORIGINATOR_FUNC bool        __cdecl OgnDeliveryState_NameToVal (OgnSeq, OgnDeliveryState::E& v);
ORIGINATOR_FUNC OgnResult   __cdecl OgnDeliveryState_Values    (OgnEnumValues& x);



struct OgnSendStage { enum E : uint32_t {
	None				=    0,
	Unknown				=  100,
	RelayLookup			=  150,
	FindMx				=  200,
	Connect				=  300,
	Greeting			=  400,
	Cmd_Ehlo			=  500,
	Capabilities		=  600,
	Tls					=  700,
	Cmd_Auth			=  750,
	Cmd_MailFrom		=  800,
	Cmd_RcptTo			=  900,
	Cmd_Data			= 1000,
	Content				= 1100,
	Cmd_Quit			= 1200,
}; };

ORIGINATOR_FUNC char const* __cdecl OgnSendStage_Name      (uint32_t v);
ORIGINATOR_FUNC char const* __cdecl OgnSendStage_Desc      (uint32_t v);
ORIGINATOR_FUNC bool        __cdecl OgnSendStage_NameToVal (OgnSeq, OgnSendStage::E& v);
ORIGINATOR_FUNC OgnResult   __cdecl OgnSendStage_Values    (OgnEnumValues& x);



struct OgnSendErr { enum E : uint32_t {
	None									=         0,
	Unknown									=      1000,
	RelayLookup_LookupTimedOut				=   5001000,
	RelayLookup_LookupError					=   5002000,
	FindMx_LookupTimedOut					=  10001000,
	FindMx_LookupError						=  10002000,
	FindMx_LookupNoResults					=  10003000,
	FindMx_DomainMatchRequired				=  10004000,
	Connect_Error							=  20001000,
	Send_Error								=  30001000,
	Reply_PrematureEndOfLine				=  40001000,
	Reply_UnrecognizedCodeFormat			=  40002000,
	Reply_UnrecognizedLineSeparator			=  40003000,
	Reply_InconsistentCode					=  40004000,
	Reply_MaximumLengthExceeded				=  40005000,
	Reply_ReceiveError						=  40006000,
	Greeting_SessionRefused					=  50001000,
	Greeting_Unexpected						=  50002000,
	Ehlo_UnexpectedReply					=  60001000,
	Capabilities_8BitMimeRequired			=  70001000,
	Capabilities_Size						=  70002000,
	Tls_NotAvailable						=  80001000,
	Tls_StartTlsRejected					=  80002000,
	Tls_SspiErr_LikelyDh_TooManyRestarts	=  80003000,
	Tls_SspiErr_InvalidToken_IllegalMsg		=  80004000,
	Tls_SspiErr_ServerAuthRequired			=  80005000,
	Tls_SspiErr_Other						=  80006000,
	Tls_CommunicationErr					=  80007000,
	Tls_RequiredAssuranceNotAchieved		=  80008000,
	Auth_AuthCommandNotSupported			=  85001000,
	Auth_CfgAuthMechNotSupported			=  85002000,
	Auth_NoSuitableAuthMechanism			=  85003000,
	Auth_CfgAuthMechUnrecognized			=  85004000,
	Auth_Rejected							=  85005000,
	Auth_UnexpectedReply					=  85006000,
	Auth_UnexpectedCramMd5ChallengeReply	=  85007000,
	MailFrom_Rejected						=  90001000,
	MailFrom_UnexpectedReply				=  90002000,
	RcptTo_Rejected							= 100001000,
	RcptTo_UnexpectedReply					= 100002000,
	Data_Rejected							= 110001000,
	Data_UnexpectedReply					= 110002000,
	Content_Rejected						= 120001000,
	Content_UnexpectedReply					= 120002000,
}; };

ORIGINATOR_FUNC char const* __cdecl OgnSendErr_Name      (uint32_t v);
ORIGINATOR_FUNC char const* __cdecl OgnSendErr_Desc      (uint32_t v);
ORIGINATOR_FUNC bool        __cdecl OgnSendErr_NameToVal (OgnSeq, OgnSendErr::E& v);
ORIGINATOR_FUNC OgnResult   __cdecl OgnSendErr_Values    (OgnEnumValues& x);



struct OgnValidResult
{
	bool				m_valid                     {};	// If true, the values of other fields are undefined
	size_t				m_bestToOffset              {}; // Raw byte offset of the first byte or character that could not be parsed
	size_t				m_bestToRow                 {}; // Row number (first = 1) of the first byte or character that could not be parsed
	size_t				m_bestToColumn              {}; // Column number (first = 1). Tab stops and UTF-8 character widths are accounted for
};



struct OgnEmailAddress
{
	void*				m_storage                   {};	// If non-null, MUST be freed by the user with CoTaskMemFree; otherwise memory is leaked
	OgnSeq				m_localPart;
	OgnSeq				m_domain;
};



struct OgnMailbox
{
	void*				m_storage                   {};	// If non-null, MUST be freed by the user with CoTaskMemFree; otherwise memory is leaked
	OgnSeq				m_name;
	OgnSeq				m_localPart;
	OgnSeq				m_domain;
};



struct OgnDkimKeypair
{
	void*				m_storage                   {};	// If non-null, MUST be freed by the user with CoTaskMemFree; otherwise memory is leaked
	OgnSeq				m_pubKeyText;
	OgnSeq				m_privKeyBin;
};



struct OgnMsgHeaders
{
	OgnMailbox			m_fromMailbox;
	size_t				m_nrToMailboxes             {};
	OgnMailbox const*	m_toMailboxes               {};
	size_t				m_nrCcMailboxes             {};
	OgnMailbox const*	m_ccMailboxes               {};
	OgnSeq				m_subject;
	OgnAutoSbmtd::E     m_autoSbmtd                 {};	// Leave at default value (OgnAutoSbmtd::Invalid) to NOT include an Auto-Submitted header field

	OgnSeq				m_dkimSdid;
	OgnSeq				m_dkimSelector;
	OgnSeq				m_dkimPrivKeyBin;				// Leave empty for no DKIM signing
};



struct OgnMsgPart;

struct OgnMsgParts
{	
	size_t				m_nrParts                   {};
	OgnMsgPart const*	m_parts                     {};
};

struct OgnMsgPart
{
	OgnSeq				m_contentType;
	bool				m_isNested                  {};
	OgnSeq              m_content;						// If not nested
	OgnMsgParts			m_nested;						// If nested
};



struct OgnStringResult
{
	void*				m_storage                   {};	// If non-null, MUST be freed by the user with CoTaskMemFree; otherwise memory is leaked
	OgnSeq				m_str;
};



struct OgnObjId
{
	uint64_t			m_uniqueId                  {};
	uint64_t            m_index                     {};
};



struct OgnSendFailure
{
	OgnSendStage::E		m_stage     {};
	OgnSendErr::E		m_err       {};
	OgnSeq				m_mx        {};
	uint64_t			m_replyCode {};
	uint64_t			m_enhStatus {};
	OgnSeq				m_desc      {};
	size_t				m_nrLines   {};
	OgnSeq const*		m_lines     {};
};



struct OgnMbxResult
{
	uint64_t				m_time      {};				// FILETIME. This may differ even in same send attempt if some mailboxes succeed and others fail; failures before successes
	OgnSeq					m_mailbox   {};
	OgnDeliveryState::E		m_state     {};
	OgnSeq					m_successMx {};
	OgnSendFailure const*	m_failure   {};
};



struct OgnMsgToSend
{
	OgnObjId			m_entityId                  {}; // When sending, must be left at default value ({0,0} == ObjId::Null)
	uint64_t			m_nextAttemptTime           {}; // FILETIME. When sending, any value less than current time (in UTC) will cause the message to be sent immediately
	OgnMsgStatus::E		m_status                    {}; // When sending, must be left at default value (0 == OgnMsgStatus::Idle)
	bool                m_customRetrySchedule       {}; // If true, m_nrFutureRetryDelayMinutes and m_futureRetryDelayMinutes are used. If false, these fields are ignored
	size_t				m_nrFutureRetryDelayMinutes {}; // If m_customRetrySchedule is true and this field is zero, Originator will not make any retries at all
	uint64_t const*		m_futureRetryDelayMinutes   {}; // After each temporary failure, next value is popped and nextAttemptTime set accordingly. When exhausted, failure is permanent
	OgnTlsAssurance::E	m_tlsRequirement            {};
	size_t				m_nrAdditionalMatchDomains  {};
	OgnSeq const*		m_additionalMatchDomains    {}; // If tlsRequirement == Tls_DomainMatch, additional domain names that also match; e.g. "google.com" for email sent to GMail
	uint64_t			m_baseSendSecondsMax        {}; // Pass zero to rely only on the extremely long timeouts defined by the SMTP RFC
	uint64_t			m_minSendBytesPerSec        {}; // Used if m_baseSendSecondsMax != 0. The smaller this number, the more the maximum send time is extended by message size
	OgnSeq				m_fromAddress               {};
	size_t				m_nrPendingMailboxes        {};
	OgnSeq const*		m_pendingMailboxes          {}; // Mailboxes are removed as delivery succeeds or permanently fails
	OgnSeq				m_toDomain                  {};
	OgnSeq				m_content                   {};
	OgnSeq				m_deliveryContext           {}; // Arbitrary binary data for use by the sending application
	size_t				m_nrMailboxResults          {};
	OgnMbxResult const*	m_mailboxResults            {}; // Ignored when sending. On message enumeration, contains info about past delivery results
};



typedef bool (__cdecl* OgnFn_EnumStr)   (void*, OgnSeq);								// Return true to continue enumeration, false to stop

typedef void (__cdecl* OgnFn_LogEvent)  (void*, uint32_t eventType, OgnSeq text);		// Windows event types: EVENTLOG_ERROR_TYPE (1), EVENTLOG_WARNING_TYPE (2), EVENTLOG_INFORMATION_TYPE (4)
typedef void (__cdecl* OgnFn_OnReset)   (void*, size_t nrMsgs, OgnMsgToSend const* msgs);
typedef void (__cdecl* OgnFn_OnAttempt) (void*, OgnMsgToSend const& msg);

// For the status of the message, check msg.m_status. This might be set to e.g. OgnMsgStatus::GivenUp if delivery failed temporarily and the retry schedule has been exhausted.
// The "mailboxResults" array contains more detailed information about the last delivery, which can be useful for diagnostics.
typedef void (__cdecl* OgnFn_OnResult)  (void*, OgnMsgToSend const& msg, size_t nrMailboxResults, OgnMbxResult const* mailboxResults, OgnTlsAssurance::E tlsAssuranceAchieved);

typedef bool (__cdecl* OgnFn_EnumMsgs)  (void*, size_t nrMsgs, OgnMsgToSend const* msgs);	// Return true to continue enumeration, false to stop



struct OgnServiceSettings
{
	OgnSeq				m_storeDir;
	size_t				m_openOversizeFilesTarget { 10 };
	size_t				m_cachedPagesTarget       { 100 };

	OgnFn_LogEvent		m_logEvent                {};
	OgnFn_OnReset		m_onReset                 {};
	OgnFn_OnAttempt		m_onAttempt               {};
	OgnFn_OnResult		m_onResult                {};
};



struct OgnSmtpSettings
{
	OgnSeq				m_senderComputerName;
	OgnIpVerPref::E		m_ipVerPref           {};	// When making outgoing SMTP connections, whether to prefer IPv4, IPv6, or neither. Dominates destination domain MX preference
	bool				m_useRelay            {};	// If false, remaining fields do not matter: SmtpSender will look up destination mail exchangers and send directly
	OgnSeq				m_relayHost;				// DNS name, IPv4 address or IPv6 address. Should be DNS name for TLS
	uint32_t			m_relayPort           {};
	bool				m_relayImplicitTls    {};	// If true, assume TLS from the start of the connection. Otherwise, start plaintext SMTP and use STARTTLS later
	OgnTlsAssurance::E	m_relayTlsRequirement {};	// TLS assurance required for connection to the relay mail exchanger, not the destination MX
	OgnAuthType::E		m_relayAuthType       {};	// If MailAuthType::None, remaining auth-related fields do not matter
	OgnSeq				m_relayUsername;
	OgnSeq				m_relayPassword;			// Must be decryptable using Crypt::UnprotectData
};



// May be called at any time. Checks validity of the provided string as an RFC 5322 dot-atom or domain-literal.
// Note that both dot-atom and domain-literal MAY contain comments and whitespace.
ORIGINATOR_FUNC OgnResult __cdecl Originator_IsValidDomain(OgnSeq domain, OgnValidResult& result);

// May be called at any time. Checks validity of the provided string as a casual email address list.
// For more information about input format, see Originator_ForEachAddressInCasualEmailAddressList.
ORIGINATOR_FUNC OgnResult __cdecl Originator_IsValidCasualEmailAddressList(OgnSeq casualAddressList, OgnValidResult& result);

// May be called at any time. Enumerates email addresses separated by commas, semicolons, newlines, spaces, or even nothing (<aa@bb>cc@dd<ee@ff>).
// Supports IMF addr-spec (user@example.com), IMF mailbox ("First Last" <user@example.com>), IMF group (group:user@example.com,other@example.com;)
// For IMF group, each address is enumerated separately. If input can't be parsed, an error is returned and no addresses are enumerated.
// Folding whitespace (with newlines) in email addresses is valid, and will be preserved if it's in a comment within the local part:
// - "multiline\r\n @example.com" is rewritten as "multiline@example.com" (newline not preserved - not in comment)
// - "multiline@(\r\n )example.com" is rewritten as "multiline@example.com" (newline not preserved - comments in domain part are dropped)
// - "multiline(\r\n )@example.com" is preserved with newline included (newline preserved - comments in local part are kept)
ORIGINATOR_FUNC OgnResult __cdecl Originator_ForEachAddressInCasualEmailAddressList(OgnSeq casualAddressList, OgnStringResult& parseErr, OgnFn_EnumStr fn, void* fnCx);

// May be called at any time. Checks validity of the provided string as an RFC 5322 addr-spec (no angle brackets).
// addr-spec == local-part "@" domain. Note: local-part may contain a quoted string; domain can be either a dot-atom or domain-literal and MAY contain comments and whitespace
ORIGINATOR_FUNC OgnResult __cdecl Originator_IsValidEmailAddress(OgnSeq address, OgnValidResult& result);

// May be called at any time. Checks validity of the provided string as an RFC 5322 addr-spec or name-addr.
// Examples: john.doe@example.com, "John Doe" <john.doe@example.com>
ORIGINATOR_FUNC OgnResult __cdecl Originator_IsValidMailbox(OgnSeq mailbox, OgnValidResult& result);

// May be called at any time. If input is invalid, storage is not allocated and the result members are empty
ORIGINATOR_FUNC OgnResult __cdecl Originator_SplitEmailAddress(OgnSeq address, OgnEmailAddress& parts);
ORIGINATOR_FUNC OgnResult __cdecl Originator_SplitMailbox(OgnSeq mailbox, OgnMailbox& parts);

// May be called at any time. Initializes cryptographic handles needed for random number generation and use of DKIM keypairs.
// May be called multiple times. Must be coupled with exactly the same number of calls to Originator_CryptFree.
ORIGINATOR_FUNC OgnResult __cdecl Originator_CryptInit();

// If the DLL is going to be unloaded, one call must be made for each time Originator_CryptInit was called previously.
ORIGINATOR_FUNC OgnResult __cdecl Originator_CryptFree();

// Must be called after Originator_CryptInit, but does not require Originator_Start.
// In particular, can be called from a process which never starts the Originator service.
// Generates a DKIM keypair which can later be used with Originator_GenerateMessageFromParts/FromMarkdown.
ORIGINATOR_FUNC OgnResult __cdecl Originator_GenerateDkimKeypair(OgnDkimKeypair& keypair);

// Must be called after Originator_CryptInit, but does not require Originator_Start.
// In particular, can be called from a process which never starts the Originator service.
// Accepts a DKIM private key and exports the corresponding public key.
ORIGINATOR_FUNC OgnResult __cdecl Originator_GetDkimPubKeyFromPrivKey(OgnSeq privKeyBin, OgnStringResult& pubKeyText);

// Must be called after Originator_CryptInit, but does not require Originator_Start.
// Composes content for a ready-to-send message using current timestamp and provided headers and body parts. Body parts will be Base64-encoded
ORIGINATOR_FUNC OgnResult __cdecl Originator_GenerateMessageFromParts(OgnMsgHeaders const& headers, OgnMsgPart const& body, OgnStringResult& content);

// Must be called after Originator_CryptInit, but does not require Originator_Start.
// Composes content for a ready-to-send message using current timestamp and provided Markdown input and optional additional attachments.
// Markdown is converted to plain text and HTML with both versions included. All body parts will be Base64-encoded
ORIGINATOR_FUNC OgnResult __cdecl Originator_GenerateMessageFromMarkdown(OgnMsgHeaders const& headers, OgnSeq markdown, OgnMsgParts const& attachments, OgnStringResult& content);

// May be called at any time. The result MAY be outdated by the time it is returned.
ORIGINATOR_FUNC OgnResult __cdecl Originator_GetServiceState(OgnServiceState::E& state);

// Must be called BEFORE Originator_Start.
ORIGINATOR_FUNC OgnResult __cdecl Originator_SetServiceSettings(OgnServiceSettings const& settings);

// May be called at any time before or after Originator_Start.
// If not called, default settings will send to destination mail exchangers directly.
ORIGINATOR_FUNC OgnResult __cdecl Originator_SetSmtpSettings(OgnSmtpSettings const& settings);

// Starts the Originator service. This is not a Windows service, but an in-process service implemented by the Originator DLL.
// If a store is not created yet, this creates it in the directory configured via Originator_SetServiceSettings.
// If a store exists and contains queued messages, Originator will begin to send them.
// When the application is ready to stop, it should call Originator_BeginStop followed by Originator_WaitStop.
// Originator_Start can be called again only after the Originator service has fully stopped.
// If Originator_Start succeeds, the Originator service will enter OgnServiceState::Started just before the function returns.
ORIGINATOR_FUNC OgnResult __cdecl Originator_Start();

// Queues a message for sending. May be called after Originator_Start and before Originator_BeginStop.
ORIGINATOR_FUNC OgnResult __cdecl Originator_SendMessage(OgnMsgToSend const& msg);

// Enumerates messages in queue (messages which have not yet been delivered to all pending mailboxes, likely due to temporary failures).
// The enumeration callback is called from outside of a transaction, so the information must be considered likely out of date by the time it is reported.
// If there are many messages in queue, the callback is called multiple times, once for each batch of messages retrieved in a separate transaction.
ORIGINATOR_FUNC OgnResult __cdecl Originator_EnumMessages(OgnFn_EnumMsgs fn, void* fnCx);

// Attempts to remove an idle message in queue (a message which has not yet been delivered to all pending mailboxes, likely due to temporary failures).
// Removal can fail if the message is no longer in queue (e.g. because it has been sent) or because a send attempt is in progress.
// This function MAY be called from the Originator_EnumMessages callback.
ORIGINATOR_FUNC OgnResult __cdecl Originator_RemoveIdleMessage(OgnObjId entityId, OgnRemoveResult::E& result);

// Signals the Originator service to stop. This causes all message sending activity to be aborted. Returns immediately. See also Originator_WaitStop.
// The Originator service must have been successfully started in order to call Originator_BeginStop.
ORIGINATOR_FUNC OgnResult __cdecl Originator_BeginStop();

// Checks if the Originator service has stopped yet. If it has stopped, closes the Originator store. Must be called AFTER Originator_BeginStop.
// Function MAY be called from multiple threads and is intended to behave correctly as long as Originator_BeginStop has been called.
// Waits for up to the specified number of milliseconds for a full stop. For waitMs, INFINITE (0xFFFFFFFF) is a valid value and will
// receive appropriate treatment. The 'stopped' parameter is set to true if stopped, false if not. If not stopped, function can be called again.
ORIGINATOR_FUNC OgnResult __cdecl Originator_WaitStop(uint32_t waitMs, bool& stopped);



#pragma pack (pop)
#pragma warning (pop)
