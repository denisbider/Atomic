#include "AtIncludes.h"
#include "AtImfDateTime.h"

#include "AtWinErr.h"


namespace At
{
	namespace Imf
	{

		void DayMonthYear::Read(ParseNode const& dateNode)
		{
			EnsureThrow(dateNode.IsType(id_date));

			// Day
			ParseNode const& dayDigitsNode { dateNode.DeepFindRef(id_day_digits) };
			m_day = dayDigitsNode.SrcText().ReadNrUInt16Dec();
			if (m_day == UINT16_MAX)
				throw InputErr("Invalid day of month digits");

			// Month
			ParseNode const& monthNode { dateNode.DeepFindRef(id_month) };
			Seq mon { monthNode.SrcText() };
			if (mon.n != 3)
				throw InputErr("Unexpected month name length");

			// This relies on that the parser won't let through anything other than the alternatives we expect
			switch (mon.p[0])
			{
			case 'A': case 'a': switch (mon.p[1]) {	case 'P': case 'p':											m_month =  4; goto HaveMonth;		// Apr
													default:													m_month =  8; goto HaveMonth; }		// Aug
			case 'D': case 'd':																					m_month = 12; goto HaveMonth;		// Dec
			case 'F': case 'f':																					m_month =  2; goto HaveMonth;		// Feb
			case 'J': case 'j': switch (mon.p[1]) {	case 'A': case 'a':											m_month =  1; goto HaveMonth;		// Jan
													default:			switch (mon.p[2]) {	case 'L': case 'l': m_month =  7; goto HaveMonth;       // Jul
																							default:			m_month =  6; goto HaveMonth; } }	// Jun
			case 'M': case 'm':											switch (mon.p[2]) {	case 'R': case 'r': m_month =  3; goto HaveMonth;		// Mar
																							default:			m_month =  5; goto HaveMonth; }		// May
			case 'N': case 'n':																					m_month = 11; goto HaveMonth;		// Nov
			case 'O': case 'o':																					m_month = 10; goto HaveMonth;		// Oct
			case 'S': case 's':																					m_month =  9; goto HaveMonth;		// Sep
			default:
				throw InputErr("Unexpected month name");
			}

		HaveMonth:

			// Year
			ParseNode const& yearDigitsNode { dateNode.DeepFindRef(id_year_digits) };
			Seq yearDigits { yearDigitsNode.SrcText() };
			m_year = yearDigits.ReadNrUInt16Dec();
			if (m_year == UINT16_MAX)
				throw InputErr("Invalid year digits");

			if (m_year < 100 && yearDigits.n <= 2)
			{
				// RFC 822 (published 1982) was last IMF spec to use 2 digit years.
				// RFC 1123 (published 1989) changed syntax to 2-4 digits and recommended all mail software to use 4-digit years.
				// It seems likely that a rare relic using 2-digit years would be running somewhere 10 years later; possible 20 years later; but unlikely 40 years later.
				// We therefore estimate that the latest date generated by 2-digit software might refer to no later than 2029.
				// Experimentation shows that in .NET, [DateTime]::ParseExact(..., "MM/dd/yy", ...) also uses December 31, 2029, as cut-off.
				if (m_year >= 30)
					m_year += 1900;
				else
					m_year += 2000;
			}
		}


		void HourMinSecTz::Read(ParseNode const& timeNode)
		{
			EnsureThrow(timeNode.IsType(id_time));

			m_hour = UINT16_MAX;
			m_minute = UINT16_MAX;
			m_second = 0;
			m_tzBias = 0;

			int nrTwoDigitGroups {};
			for (ParseNode const& c : timeNode)
			{
				if (c.IsType(id_2digits))
				{
					uint16 v { c.SrcText().ReadNrUInt16Dec() };
					if (v == UINT16_MAX)
						throw InputErr("Invalid hour/minute/second digits");

					switch (++nrTwoDigitGroups)
					{
					case 1: m_hour   = v; break;
					case 2: m_minute = v; break;
					case 3: m_second = v; break;
					}
				}
				else if (c.IsType(id_zone))
				{
					Seq zon { c.SrcText() };
					if (zon.n == 1)
					{
						// Obsolete time zone, military format
						switch (zon.p[0])
						{
						case 'A': case 'a': m_tzBias =   60; break;
						case 'B': case 'b': m_tzBias =  120; break;
						case 'C': case 'c': m_tzBias =  180; break;
						case 'D': case 'd': m_tzBias =  240; break;
						case 'E': case 'e': m_tzBias =  300; break;
						case 'F': case 'f': m_tzBias =  360; break;
						case 'G': case 'g': m_tzBias =  420; break;
						case 'H': case 'h': m_tzBias =  480; break;
						case 'I': case 'i': m_tzBias =  540; break;
						case 'K': case 'k': m_tzBias =  600; break;
						case 'L': case 'l': m_tzBias =  660; break;
						case 'M': case 'm': m_tzBias =  720; break;
						case 'N': case 'n': m_tzBias =  -60; break;
						case 'O': case 'o': m_tzBias = -120; break;
						case 'P': case 'p': m_tzBias = -180; break;
						case 'Q': case 'q': m_tzBias = -240; break;
						case 'R': case 'r': m_tzBias = -300; break;
						case 'S': case 's': m_tzBias = -360; break;
						case 'T': case 't': m_tzBias = -420; break;
						case 'U': case 'u': m_tzBias = -480; break;
						case 'V': case 'v': m_tzBias = -540; break;
						case 'W': case 'w': m_tzBias = -600; break;
						case 'X': case 'x': m_tzBias = -660; break;
						case 'Y': case 'y': m_tzBias = -720; break;
						case 'Z': case 'z': m_tzBias =    0; break;
						default:			throw InputErr("Unexpected military time zone");
						}
					}
					else if (zon.n == 2 || zon.n == 3)
					{
						// Obsolete time zone, civilian
						// This relies on that the parser won't let through anything other than the alternatives we expect
						switch (zon.p[0])
						{
						case 'C': case 'c': switch (zon.p[1]) { case 'S': case 's': m_tzBias = -360; goto HaveTz;		// CST
																default:			m_tzBias = -300; goto HaveTz; }		// CDT
						case 'E': case 'e': switch (zon.p[1]) { case 'S': case 's': m_tzBias = -300; goto HaveTz;		// EST
																default:			m_tzBias = -240; goto HaveTz; }		// EDT
						case 'G': case 'g':											m_tzBias =    0; goto HaveTz;		// GMT
						case 'M': case 'm': switch (zon.p[1]) { case 'S': case 's': m_tzBias = -420; goto HaveTz;		// MST
																default:			m_tzBias = -360; goto HaveTz; }		// MDT
						case 'P': case 'p': switch (zon.p[1]) { case 'S': case 's': m_tzBias = -480; goto HaveTz;		// PST
																default:			m_tzBias = -420; goto HaveTz; }		// PDT
						case 'U': case 'u':											m_tzBias =    0; goto HaveTz;		// UT
						default:
							throw InputErr("Unexpected civilian time zone");
						}
	
					HaveTz: ;
					}
					else if (zon.n == 5)
					{
						// Standard time zone
						bool negative { (zon.ReadByte() == '-') };
						uint16 tz { zon.ReadNrUInt16Dec() };
						if (tz == UINT16_MAX)
							throw InputErr("Unexpected standard time zone value");

						m_tzBias = ((tz / 100) * 60) + (tz % 100);
						if (negative)
							m_tzBias = -m_tzBias;
					}
					else
						throw InputErr("Unexpected time zone format");

					break;
				}
			}
		}


		void DateTime::Read(ParseNode const& dateTimeNode)
		{
			EnsureThrow(dateTimeNode.IsType(id_date_time));

			DayMonthYear dmy;
			HourMinSecTz hmst;
			dmy.Read(dateTimeNode.FlatFindRef(id_date));
			hmst.Read(dateTimeNode.FlatFindRef(id_time));

			SYSTEMTIME stLocal {};
			stLocal.wYear   = dmy.m_year;
			stLocal.wMonth  = dmy.m_month;
			stLocal.wDay    = dmy.m_day;
			stLocal.wHour   = hmst.m_hour;
			stLocal.wMinute = hmst.m_minute;
			stLocal.wSecond = hmst.m_second;

			TIME_ZONE_INFORMATION tzi {};
			tzi.Bias = hmst.m_tzBias;

			SYSTEMTIME stUniversal;
			if (!TzSpecificLocalTimeToSystemTime(&tzi, &stLocal, &stUniversal))
				{ LastWinErr e; throw e.Make<InputErr>("Error converting datetime to universal time zone at TzSpecificLocalTimeToSystemTime"); }

			uint64 ft;
			if (!SystemTimeToFileTime(&stUniversal, (FILETIME*) &ft))
				{ LastWinErr e; throw e.Make<InputErr>("Error converting datetime to 64-bit integer at SystemTimeToFileTime"); }

			m_t = Time::FromFt(ft);
		}


		void DateTime::Write(MsgWriter& writer) const
		{
			AuxStr auxStr { writer };
			m_t.Enc_Email(auxStr);
			writer.Add(auxStr);
		}		

	}
}

